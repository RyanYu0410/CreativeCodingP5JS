<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D跳一跳</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        #score {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="score">Score: 0</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player, playerBody, playerHead, platforms = [];
        let score = 0;
        let jumping = false;
        let jumpVelocityY = 0;
        let gravity = 0.6;
        let jumpPower = 15;
        let maxHorizontalDisplacement = 20;
        let indicator, mousePressStart = 0;
        let charging = false;
        let gameEnded = false;
        let jumpDirection = new THREE.Vector3();
        let targetPlatform;
        let landingPredictor; // 落点预测指示器
        let powerBar; // 蓄力条
        let jumpTrajectory; // 跳跃轨迹线
        let playerShadow; // 玩家阴影

        function init() {
            console.log("Initializing game scene...");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            platforms = [];
            const initialPlatform = createPlatform(0, 0, 8);
            platforms.push(initialPlatform);
            scene.add(initialPlatform);
            
            generateNewPlatform();

            player = createPlayer();
            scene.add(player);

            // 创建玩家阴影
            playerShadow = createPlayerShadow();
            scene.add(playerShadow);

            // 创建落点预测指示器
            landingPredictor = createLandingPredictor();
            scene.add(landingPredictor);

            // 创建蓄力条
            powerBar = createPowerBar();
            scene.add(powerBar);

            // 创建跳跃轨迹线
            jumpTrajectory = createJumpTrajectory();
            scene.add(jumpTrajectory);

            if ('ontouchstart' in window) {
                renderer.domElement.addEventListener('touchstart', onTouchStart);
                renderer.domElement.addEventListener('touchend', onTouchEnd);
            } else {
                renderer.domElement.addEventListener('mousedown', onMouseDown);
                renderer.domElement.addEventListener('mouseup', onMouseUp);
            }

            animate();
        }

        function createPlatform(x, y, size) {
            const geometry = new THREE.BoxGeometry(size, 2, size);
            const material = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                shininess: 100 
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, 0);
            platform.receiveShadow = true;
            return platform;
        }

        function createPlayer() {
            const group = new THREE.Group();
            
            // 创建身体
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 32);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x2196F3 });
            playerBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            playerBody.position.y = 0.6;
            playerBody.castShadow = true;
            group.add(playerBody);

            // 创建头部
            const headGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFE0B2 });
            playerHead = new THREE.Mesh(headGeometry, headMaterial);
            playerHead.position.y = 1.35;
            playerHead.castShadow = true;
            group.add(playerHead);

            // 创建手臂
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x2196F3 });
            
            // Left arm
            const leftUpperArm = new THREE.Mesh(armGeometry, armMaterial);
            leftUpperArm.position.set(-0.4, 0.9, 0);
            leftUpperArm.rotation.z = Math.PI / 6;
            leftUpperArm.castShadow = true;
            group.add(leftUpperArm);

            const leftLowerArm = new THREE.Mesh(armGeometry, armMaterial);
            leftLowerArm.position.set(-0.5, 0.7, 0);
            leftLowerArm.rotation.z = Math.PI / 3;
            leftLowerArm.castShadow = true;
            group.add(leftLowerArm);

            // Right arm
            const rightUpperArm = new THREE.Mesh(armGeometry, armMaterial);
            rightUpperArm.position.set(0.4, 0.9, 0);
            rightUpperArm.rotation.z = -Math.PI / 6;
            rightUpperArm.castShadow = true;
            group.add(rightUpperArm);

            const rightLowerArm = new THREE.Mesh(armGeometry, armMaterial);
            rightLowerArm.position.set(0.5, 0.7, 0);
            rightLowerArm.rotation.z = -Math.PI / 3;
            rightLowerArm.castShadow = true;
            group.add(rightLowerArm);

            // 创建腿
            const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.4, 16);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x1565C0 });

            const leftUpperLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftUpperLeg.position.set(-0.2, 0.2, 0);
            leftUpperLeg.castShadow = true;
            group.add(leftUpperLeg);

            const leftLowerLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLowerLeg.position.set(-0.2, -0.2, 0);
            leftLowerLeg.castShadow = true;
            group.add(leftLowerLeg);

            const rightUpperLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightUpperLeg.position.set(0.2, 0.2, 0);
            rightUpperLeg.castShadow = true;
            group.add(rightUpperLeg);

            const rightLowerLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLowerLeg.position.set(0.2, -0.2, 0);
            rightLowerLeg.castShadow = true;
            group.add(rightLowerLeg);

            group.position.y = 2;
            return group;
        }

        function createPlayerShadow() {
            const geometry = new THREE.CircleGeometry(0.5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.3
            });
            const shadow = new THREE.Mesh(geometry, material);
            shadow.rotation.x = -Math.PI / 2;
            return shadow;
        }

        function createLandingPredictor() {
            const geometry = new THREE.RingGeometry(0.5, 0.7, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const predictor = new THREE.Mesh(geometry, material);
            predictor.rotation.x = -Math.PI / 2; // 使圆环平躺
            predictor.visible = false;
            return predictor;
        }

        function createPowerBar() {
            const geometry = new THREE.BoxGeometry(0.2, 5, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const bar = new THREE.Mesh(geometry, material);
            bar.visible = false;
            return bar;
        }

        function createJumpTrajectory() {
            const points = [];
            for(let i = 0; i < 50; i++) {
                points.push(new THREE.Vector3(0, 0, 0));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
            return new THREE.Line(geometry, material);
        }

        function generateNewPlatform() {
            const lastPlatform = platforms[platforms.length - 1];
            const minDistance = 5;
            const maxDistance = 15;
            let validPosition = false;
            let newPlatform;
            
            while (!validPosition) {
                const distance = Math.random() * (maxDistance - minDistance) + minDistance;
                const angle = Math.random() * Math.PI * 2; // Random angle for full 360 degree placement
                const x = lastPlatform.position.x + Math.cos(angle) * distance;
                const z = lastPlatform.position.z + Math.sin(angle) * distance;
                const y = Math.random() * 4 - 2; // Random height variation between -2 and 2
                const size = Math.random() * 3 + 5;
                
                newPlatform = createPlatform(x, y, size);
                
                // Check for intersection with existing platforms
                validPosition = true;
                for (let platform of platforms) {
                    const dx = newPlatform.position.x - platform.position.x;
                    const dy = newPlatform.position.y - platform.position.y;
                    const dz = newPlatform.position.z - platform.position.z;
                    const minDistance = (newPlatform.geometry.parameters.width + platform.geometry.parameters.width) / 2;
                    
                    if (Math.sqrt(dx * dx + dy * dy + dz * dz) < minDistance) {
                        validPosition = false;
                        break;
                    }
                }
            }
            
            // Remove old platforms to prevent memory issues
            if (platforms.length > 5) {
                scene.remove(platforms[0]);
                platforms.shift();
            }
            
            platforms.push(newPlatform);
            scene.add(newPlatform);
            targetPlatform = newPlatform;
        }

        function updateTrajectoryPredictor(power) {
            if (!charging || !targetPlatform) return;

            const direction = new THREE.Vector3()
                .subVectors(targetPlatform.position, player.position)
                .normalize();
            
            const points = [];
            const simulatedPos = new THREE.Vector3().copy(player.position);
            let simulatedVelocityY = power;
            const simulatedDirection = direction.clone().multiplyScalar(power * 0.1);

            for(let i = 0; i < 50; i++) {
                points.push(new THREE.Vector3().copy(simulatedPos));
                simulatedPos.x += simulatedDirection.x;
                simulatedPos.z += simulatedDirection.z;
                simulatedPos.y += simulatedVelocityY * 0.1;
                simulatedVelocityY -= gravity;
            }

            jumpTrajectory.geometry.setFromPoints(points);
            jumpTrajectory.visible = true;

            // 更新落点预测器位置
            const landingPoint = calculateLandingPoint(power, direction);
            landingPredictor.position.copy(landingPoint);
            landingPredictor.visible = true;
        }

        function calculateLandingPoint(power, direction) {
            const simulatedPos = new THREE.Vector3().copy(player.position);
            let simulatedVelocityY = power;
            const simulatedDirection = direction.clone().multiplyScalar(power * 0.1);

            while(simulatedPos.y > targetPlatform.position.y) {
                simulatedPos.x += simulatedDirection.x;
                simulatedPos.z += simulatedDirection.z;
                simulatedPos.y += simulatedVelocityY * 0.1;
                simulatedVelocityY -= gravity;
            }

            simulatedPos.y = targetPlatform.position.y + 0.1; // Set to platform height plus small offset
            return simulatedPos;
        }

        function onMouseDown(event) {
            if (!jumping) {
                mousePressStart = Date.now();
                charging = true;
                powerBar.visible = true;
                jumpTrajectory.visible = true;
            }
        }

        function onMouseUp(event) {
            if (charging) {
                const power = Math.min((Date.now() - mousePressStart) / 1000 * jumpPower, jumpPower * 2);
                jump(power);
                powerBar.visible = false;
                jumpTrajectory.visible = false;
                landingPredictor.visible = false;
                
                // 恢复玩家形状
                playerBody.scale.y = 1;
                playerBody.position.y = 0.6;
                playerHead.position.y = 1.35;
            }
        }

        function onTouchStart(event) {
            event.preventDefault();
            onMouseDown(event.touches[0]);
        }

        function onTouchEnd(event) {
            event.preventDefault();
            onMouseUp(event);
        }

        function jump(power) {
            if (!jumping && !gameEnded) {
                jumping = true;
                charging = false;

                const direction = new THREE.Vector3()
                    .subVectors(targetPlatform.position, player.position)
                    .normalize();
                
                jumpVelocityY = power;
                jumpDirection.copy(direction).multiplyScalar(power);
            }
        }

        function checkLanding() {
            const playerPos = player.position;
            
            for (let platform of platforms) {
                const platformPos = platform.position;
                const size = platform.geometry.parameters.width;
                
                if (playerPos.y <= platformPos.y + 2 &&
                    Math.abs(playerPos.x - platformPos.x) < size/2 &&
                    Math.abs(playerPos.z - platformPos.z) < size/2) {
                    
                    player.position.y = platformPos.y + 2;
                    jumping = false;
                    score++;
                    document.getElementById('score').textContent = `Score: ${score}`;
                    generateNewPlatform();
                    return true;
                }
            }
            
            if (playerPos.y < -10) {
                gameEnded = true;
                alert(`Game Over! Score: ${score}`);
                location.reload();
            }
            
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (jumping) {
                player.position.x += jumpDirection.x * 0.1;
                player.position.z += jumpDirection.z * 0.1;
                player.position.y += jumpVelocityY * 0.1;
                jumpVelocityY -= gravity;

                checkLanding();
            }

            if (charging) {
                const power = Math.min((Date.now() - mousePressStart) / 1000 * jumpPower, jumpPower * 2);
                const compressionRatio = 1 - (power / (jumpPower * 2)) * 0.5;
                
                // 更新玩家压缩形状
                playerBody.scale.y = compressionRatio;
                playerBody.position.y = 0.6 * compressionRatio;
                playerHead.position.y = 1.35 * compressionRatio;
                
                // 更新蓄力条
                powerBar.scale.y = power / jumpPower;
                powerBar.position.copy(player.position).add(new THREE.Vector3(2, power/2, 0));
                
                // 更新预测轨迹和落点
                updateTrajectoryPredictor(power);
            }

            // 更新玩家阴影
            const raycaster = new THREE.Raycaster(player.position, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(platforms);
            if (intersects.length > 0) {
                playerShadow.position.copy(intersects[0].point);
                playerShadow.position.y += 0.1;
                playerShadow.visible = true;
                const distance = intersects[0].distance;
                playerShadow.scale.set(1 + distance * 0.1, 1 + distance * 0.1, 1);
                playerShadow.material.opacity = Math.max(0.3 - distance * 0.03, 0);
            } else {
                playerShadow.visible = false;
            }

            // 相机跟随
            const cameraTarget = new THREE.Vector3(
                player.position.x + 15,
                player.position.y + 15,
                player.position.z + 15
            );
            camera.position.lerp(cameraTarget, 0.1);
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>